// Задание #4(дополнительное)
// К вам пришел один владелец небольшого стартапа.Он предлагает вам сделать игру,
// 	которая поразит игровую индустрию.Вы конечно же соглашаетесь, так как предложение
// звучит заманчиво.
// Суть игры состоит в том, что есть 2 замка(атакующий и защищающийся), которые
// враждуют между собой.Пользователь играет за атакующий замок.Царю атакующего
// замка необходимо каждый раз просчитывать возможности захвата враждующего замка.
// Когда возможность будет достаточно большой, то необходимо не задумываясь атаковать.
// В коде у вас изначально есть 2 объекта attacker и defender, которые являются
// аналогиями замков и у которых есть свойства, отвечающие за количество боевых единиц
// каждого типа.Например, archer - это лучники, footSoldiers - пехотинцы, и т.д.
const defender = {
	archer: 33,
	footSoldier: 50,
	cavalry: 40,
	artillery: 10,
}

const attacker = {
	archer: 30,
	footSoldier: 55,
	cavalry: 10,
	artillery: 3,
	checkChancesToWin(defenderObject = defender) {
		let chanсe = 0
		const attakerValues = Object.values(this)
		const defenderValues = Object.values(defender)
		attakerValues.forEach((value, index) => {
			if (value > defenderValues[index] && typeof value === 'number') {
				chanсe++
			}
		})
		return [chanсe, defenderValues.length]
	},
	improveArmy() {
		const attakerKeys = Object.keys(this)
		attakerKeys.forEach((key, index) => {
			if (typeof this[key] === 'number') {
				this[key] += 5
			}
		})
	},
	attack(defenderObject = defender) {
		let chances = this.checkChancesToWin()
		let chancesPer = chances[0] / chances[1] * 100
		if (chancesPer < 70) {
			this.improveArmy()
			console.log(`Наши шансы равны ${chances[0]}/${chances[1]}. Необходимо укрепление!`)
		} else {
			console.log(`Мы усилились! Мы несомненно победим! Наши шансы высоки`);
		}
	},
}


// В объекте attacker вам необходимо создать 3 функции:
// 1. checkChancesToWin Проверяет шансы атакующего замка захватить
// защищающийся замок.Данная функция принимает в себя 1 параметр
// defenderObject, который является объектом защищающегося замка - defender.Она
// должна сверять количество всех боевых единиц у обоих замков.Например, если у
// атакующего замка значение свойства archer больше, чем у защищающегося, то к
// шансам захвата необходимо прибавить 1(изначально значение шансов должно
// быть равно нулю).Функция должна возвращать массив, в котором 1 - й элемент -
// 	это шансы атакующего замка на захват, а 2 - й - это значение максимального шанса
// на захват(количество ключей в объекте defenderObject).То есть, если у
// атакующего замка значения свойств archer и cavalry больше, чем у
// защищающегося, а другие значения свойств - меньше, то шансы на захват должны
// быть[2, 4](образно шансы равны 2 из 4 либо 50 %)
// 2. improveArmy Прибавляет к каждому числовому значению объекта attacker по 5
// единиц(обновляет свойства archer, footSoldier, cavalry, artillery).Данная функция не
// принимает никаких параметров
// 3. attack Принимает в себя 1 параметр - это объект защищающегося замка defender.
// Сначала эта функция проверяет, если шансы на захват(вызываем функцию
// checkChancesToWin) меньше, чем 70 % от максимальных шансов, то необходимо
// усилиться(вызвать функцию improveArmy) и вывести сообщение через alert
// “Наши шансы равны ${ ourArmyChances } /${maximumChances}. Необходимо
// укрепление!” (ourArmyChances - шансы атакующего замка на захват,
// 	maximumChances - максимальный шанс на захват). Иначе же требуется вывести
// сообщение в модальном окне “Мы усилились! Мы несомненно победим! Наши
// шансы высоки!”
// Пример результата работы функции attack:
attacker.attack(defender); // Наши шансы равны 1/4. Необходимо укрепление!
attacker.attack(defender); // Наши шансы равны 2/4. Необходимо укрепление!
attacker.attack(defender); // Мы усилились! Мы несомненно победим! Наши шансы высоки